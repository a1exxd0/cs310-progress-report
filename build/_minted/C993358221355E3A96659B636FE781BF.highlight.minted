\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{circuit\PYGZus{}oracle\PYGZus{}f}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{f}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ndarray}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{QuantumCircuit}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Build an oracle circuit U\PYGZus{}f that maps |x\PYGZgt{}|0\PYGZgt{} \PYGZhy{}\PYGZgt{} |x\PYGZgt{}|f(x)\PYGZgt{}.}

\PYG{l+s+sd}{    This implements the standard phase\PYGZhy{}free oracle using multi\PYGZhy{}controlled X gates.}
\PYG{l+s+sd}{    For each x where f(x)=1, flip the target qubit conditioned on input being x.}

\PYG{l+s+sd}{    Parameters}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    f : np.ndarray}
\PYG{l+s+sd}{        The Boolean function values.}

\PYG{l+s+sd}{    Returns}
\PYG{l+s+sd}{    \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{l+s+sd}{    qc : QuantumCircuit}
\PYG{l+s+sd}{        Oracle circuit on n+1 qubits.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{qr} \PYG{o}{=} \PYG{n}{QuantumRegister}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{qc} \PYG{o}{=} \PYG{n}{QuantumCircuit}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{oracle\PYGZus{}f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} For each x where f(x) = 1, apply MCX controlled on |x\PYGZgt{}}
    \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dim\PYGZus{}x}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{f}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
            \PYG{c+c1}{\PYGZsh{} Determine which qubits need X gates (for 0 bits in x)}
            \PYG{n}{ctrl\PYGZus{}state} \PYG{o}{=} \PYG{n+nb}{format}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} reversed for Qiskit ordering}

            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
                \PYG{n}{qc}\PYG{o}{.}\PYG{n}{x}\PYG{p}{(}\PYG{n}{qr}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{qc}\PYG{o}{.}\PYG{n}{mcx}\PYG{p}{(}
                    \PYG{n}{control\PYGZus{}qubits}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                    \PYG{n}{target\PYGZus{}qubit}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{n}\PYG{p}{,}
                    \PYG{n}{ctrl\PYGZus{}state}\PYG{o}{=}\PYG{n}{ctrl\PYGZus{}state}
                \PYG{p}{)}

    \PYG{k}{return} \PYG{n}{qc}
\end{MintedVerbatim}
